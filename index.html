<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‰¹ç·´ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ Pro v4.0 (MyCards & Multi-Bonus)</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        :root { --primary: #00f2ff; --accent: #22c55e; --bg: #0f172a; --card: #1e293b; --text: #f1f5f9; --skill: #fbbf24; --ability: #a78bfa; --gk: #f97316; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding-bottom: 80px; }
        nav { background: #000; padding: 10px; display: flex; gap: 5px; position: sticky; top: 0; z-index: 100; overflow-x: auto; }
        .tab-btn { flex: 1; padding: 10px; border: none; background: #334155; color: white; border-radius: 6px; cursor: pointer; white-space: nowrap; font-size: 0.85rem; }
        .tab-btn.active { background: var(--primary); color: #000; font-weight: bold; }
        .content { display: none; padding: 15px; max-width: 1000px; margin: 0 auto; }
        .content.active { display: block; }
        .card-box { background: var(--card); padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid #334155; }
        input, textarea, select { background: #000; border: 1px solid #334155; color: #fff; padding: 8px; border-radius: 6px; width: 100%; box-sizing: border-box; }
        .btn { padding: 10px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; margin-top: 5px; width: 100%; }
        .btn-primary { background: var(--primary); color: #000; }
        .btn-accent { background: var(--accent); color: #fff; }
        .btn-sm { width: auto; padding: 4px 8px; font-size: 0.75rem; margin-left: 5px; }
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 8px; margin-top: 10px; }
        .stat-item label { display: block; font-size: 0.7rem; color: #94a3b8; margin-bottom: 2px; }
        .gk-stat { border-color: var(--gk); } .gk-stat label { color: var(--gk); }
        .slot-active { border: 2px solid var(--primary); background: rgba(0,242,255,0.1); }
        .slot-empty { border: 2px dashed #444; }
        .bonus-on { color: var(--accent); font-weight: bold; }
        .bonus-off { color: #ef4444; text-decoration: line-through; opacity: 0.6; }
        .tag { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; margin-right: 5px; }
        .tag-skill { background: var(--skill); color: #000; }
        .tag-ability { background: var(--ability); color: #fff; }
        
        /* Inventory Styles */
        .inv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; }
        .inv-item { background: #000; padding: 8px; border-radius: 6px; border: 1px solid #333; position: relative; }
        .inv-item.owned { border-color: var(--primary); background: rgba(0,242,255,0.05); }
        .inv-item.unowned { opacity: 0.5; }
        .inv-check { position: absolute; top: 5px; right: 5px; transform: scale(1.2); }
        
        /* Area Grid */
        .area-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 3px; width: 120px; margin-top: 5px; }
        .area-cell { height: 35px; background: #444; cursor: pointer; border: 1px solid #555; }
        .area-cell.active { background: var(--skill); border: 1px solid white; }
    </style>
</head>
<body>

<nav>
    <button class="tab-btn active" onclick="showTab('sim')">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</button>
    <button class="tab-btn" onclick="showTab('inventory')">æ‰€æŒã‚«ãƒ¼ãƒ‰</button>
    <button class="tab-btn" onclick="showTab('admin-card')">ã‚«ãƒ¼ãƒ‰ç®¡ç†</button>
    <button class="tab-btn" onclick="showTab('admin-skill')">ã‚¹ã‚­ãƒ«/ã‚¢ãƒ“ç®¡ç†</button>
</nav>

<!-- ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ -->
<div id="sim" class="content active">
    <!-- 1. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å…¥åŠ› -->
    <div class="card-box" style="border-color: #3b82f6;">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" onclick="toggleDisp('statInputArea')">
            <label style="color:#3b82f6; font-weight:bold;">â–¼ è‚²æˆé¸æ‰‹ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å…¥åŠ› (ç¾åœ¨å€¤ / æœ€å¤§å€¤)</label>
            <span style="font-size:0.8rem;">é–‹é–‰</span>
        </div>
        <div style="margin-top:10px; border-top:1px solid #334155; padding-top:10px;">
            <label style="font-size:0.7rem; color:#94a3b8; display:block; margin-bottom:5px;">ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ(16:9)ã‹ã‚‰è‡ªå‹•æŠ½å‡º</label>
            <div style="display:flex; gap:10px; align-items:center;">
                <input type="file" id="ocrUpload" accept="image/*" style="display:none;" onchange="handleOCR(this)">
                <button class="btn" style="background:#3b82f6; width:auto; font-size:0.75rem; padding:5px 15px;" onclick="document.getElementById('ocrUpload').click()">ç”»åƒã‚’é¸æŠ</button>
                <span id="ocrStatus" style="font-size:0.7rem; color:var(--skill);"></span>
            </div>
        </div>
        <div id="statInputArea" class="stat-grid" style="display:none; margin-top:10px;"></div>
    </div>

    <!-- 2. ãƒ—ãƒ¬ã‚¤ã‚¹ã‚¿ã‚¤ãƒ« & ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¹ã‚­ãƒ«é¸æŠ -->
    <div class="card-box" style="border-color: var(--accent);">
        <label style="color:var(--accent); font-weight:bold; font-size:0.8rem;">è‚²æˆè¨­å®š</label>
        <div style="display:grid; grid-template-columns: 1fr 2fr; gap:10px; margin-top:5px;">
            <div>
                <label style="font-size:0.7rem;">ãƒã‚¸ã‚·ãƒ§ãƒ³</label>
                <select id="simPos" onchange="updateStyleOptions()"></select>
            </div>
            <div>
                <label style="font-size:0.7rem;">ãƒ—ãƒ¬ã‚¤ã‚¹ã‚¿ã‚¤ãƒ«</label>
                <select id="simStyle" onchange="updateCalc()"></select>
            </div>
        </div>
        <div style="margin-top:10px;">
            <label style="font-size:0.7rem; color:var(--skill);">ç¿’å¾—ã—ãŸã„ã‚¹ã‚­ãƒ«/ã‚¢ãƒ“ãƒªãƒ†ã‚£ (å¿…é ˆæ ã¨ã—ã¦è¨ˆç®—)</label>
            <input id="targetSkillInput" list="skillList" placeholder="æŒ‡å®šãªã—" onchange="updateCalc()">
        </div>
    </div>

    <!-- 3. ç‰¹ç·´ã‚¹ãƒ­ãƒƒãƒˆ -->
    <div id="simSlots" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin-bottom:20px;"></div>

    <!-- 4. è¨­å®š & ã‚ªãƒ¼ãƒˆ -->
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:15px;">
        <div class="card-box" style="margin-bottom:0;">
            <label>ã‚³ãƒ³ãƒ‡ã‚£ã‚·ãƒ§ãƒ³</label>
            <select id="conditionMod" onchange="updateCalc()">
                <option value="1.0">æ™®é€š</option>
                <option value="1.25">å¥½èª¿</option>
                <option value="1.5">çµ¶å¥½èª¿</option>
            </select>
        </div>
        <div class="card-box" style="margin-bottom:0; border: 2px solid var(--skill);">
            <label style="color:var(--skill); font-weight:bold; font-size:0.8rem;">ğŸ¤– æœ€é©åŒ–ã‚ªãƒ¼ãƒˆç·¨æˆ</label>
            <div style="display:flex; align-items:center; gap:5px; margin-top:5px;">
                <input type="range" id="targetPct" min="50" max="120" value="100" step="5" oninput="document.getElementById('targetPctDisp').innerText=this.value">
                <span id="targetPctDisp" style="font-size:0.7rem; min-width:25px;">100</span>%
            </div>
            <button class="btn" style="background:var(--skill); color:#000; font-size:0.75rem; padding:5px;" onclick="runAutoSim()">æ‰€æŒã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€é©åŒ–</button>
        </div>
    </div>

    <!-- 5. çµæœ -->
    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
        <div id="totalResults" class="card-box"></div>
        <div id="saResults" class="card-box"></div>
    </div>
</div>

<!-- æ‰€æŒã‚«ãƒ¼ãƒ‰ç®¡ç† -->
<div id="inventory" class="content">
    <div class="card-box">
        <div style="display:flex; justify-content:space-between; align-items:center;">
            <h4>My Cards (æ‰€æŒçŠ¶æ³ & ãƒ¬ãƒ™ãƒ«)</h4>
            <div>
                <button class="btn btn-sm btn-primary" onclick="invSetAll(true)">å…¨æ‰€æŒ</button>
                <button class="btn btn-sm" onclick="invSetAll(false)">å…¨è§£é™¤</button>
            </div>
        </div>
        <p style="font-size:0.75rem; color:#94a3b8;">ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã®ã¿ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ä½¿ç”¨ã—ã¾ã™ã€‚ãƒ¬ãƒ™ãƒ«ã‚’æŒ‡å®šã™ã‚‹ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒå¤‰å‹•ã—ã¾ã™ã€‚</p>
        <div id="invList" class="inv-grid" style="margin-top:10px;"></div>
    </div>
</div>

<!-- ã‚«ãƒ¼ãƒ‰ç®¡ç† (Admin) -->
<div id="admin-card" class="content">
    <div class="card-box">
        <h4>GitHubè¨­å®š</h4>
        <input type="password" id="ghToken" placeholder="GitHub Token">
        <input type="text" id="ghRepo" placeholder="user/repo" style="margin-top:5px;">
    </div>
    <div class="card-box">
        <h4>JSONä¸€æ‹¬ç™»éŒ²</h4>
        <textarea id="aiPasteCard" placeholder="ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘" style="height:60px;"></textarea>
        <button class="btn btn-accent" onclick="batchRegisterCards()">ä¸€æ‹¬ä¿å­˜</button>
    </div>
    <div class="card-box" id="cardEditor" style="border:2px solid var(--primary);">
        <h4>å€‹åˆ¥ç·¨é›†</h4>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px;"><input id="editName" placeholder="é¸æ‰‹å"><input id="editTitle" placeholder="ã€ç§°å·ã€‘"></div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px; margin-top:5px;">
            <select id="editRarity"><option>SSR</option><option>SR</option></select>
            <input id="editAbilityName" placeholder="ã‚¹ã‚­ãƒ«/ã‚¢ãƒ“å" list="skillList">
        </div>
        
        <!-- æ–°ã—ã„ãƒœãƒ¼ãƒŠã‚¹UI -->
        <div style="margin-top:10px; border:1px dashed #555; padding:5px;">
            <label style="font-size:0.7rem;">ãƒœãƒ¼ãƒŠã‚¹æ¡ä»¶ (è¤‡æ•°å¯)</label>
            <div id="editBonusList"></div>
            <button class="btn btn-sm" onclick="addBonusRow()">+ æ¡ä»¶è¿½åŠ </button>
        </div>

        <div class="stat-grid" id="editStatsGrid"></div>
        <button class="btn btn-accent" onclick="saveCardToGH()">ä¿å­˜</button>
    </div>
    <div id="masterList"></div>
</div>

<!-- ã‚¹ã‚­ãƒ«ç®¡ç† (Admin) -->
<div id="admin-skill" class="content">
    <div class="card-box" id="saEditor" style="border:2px solid var(--primary)">
        <h4>ã‚¹ã‚­ãƒ«/ã‚¢ãƒ“ãƒªãƒ†ã‚£ç·¨é›†</h4>
        <select id="saType" onchange="toggleAreaGrid()"><option value="skill">SKILL (%)</option><option value="ability">ABILITY (å›ºå®šå€¤)</option></select>
        <input id="saName" placeholder="åç§°" style="margin-top:5px;">
        <input id="saValue" placeholder="æ•°å€¤" type="number" style="margin-top:5px;">
        <input id="saCondition" placeholder="ç™ºå‹•æ¡ä»¶" style="margin-top:5px;">
        <div id="saTargets" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(90px, 1fr)); gap:5px; margin-top:10px;"></div>
        <div id="areaContainer" style="margin-top:10px;">
            <label>ç™ºå‹•ã‚¨ãƒªã‚¢:</label><div class="area-grid" id="saAreaGrid"></div>
        </div>
        <button class="btn btn-accent" onclick="saveSA()">ä¿å­˜</button>
        <button class="btn" style="margin-top:10px; background:#444;" onclick="document.getElementById('saListArea').style.display='block'">ä¸€è¦§ã‚’è¡¨ç¤º</button>
    </div>
    <div id="saListArea" style="display:none;">
        <div class="card-box"><textarea id="aiPasteSA" placeholder="JSONä¸€æ‹¬è²¼ã‚Šä»˜ã‘" style="height:50px;"></textarea><button class="btn btn-sm" onclick="batchRegisterSA()">JSONä¿å­˜</button></div>
        <div id="saList"></div>
    </div>
</div>

<!-- ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="cardModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:200; padding:20px; overflow-y:auto;">
    <div id="modalList"></div><button class="btn" onclick="document.getElementById('cardModal').style.display='none'">é–‰ã˜ã‚‹</button>
</div>

<datalist id="skillList"></datalist>

<script>
    // --- å®šæ•°ãƒ»è¨­å®š ---
    const STATS = ["æ±ºå®šåŠ›","ã‚·ãƒ§ãƒ¼ãƒˆãƒ‘ã‚¹","çªç ´åŠ›","ã‚¸ãƒ£ãƒ³ãƒ—","èµ°åŠ›","ã‚­ãƒƒã‚¯åŠ›","ãƒ­ãƒ³ã‚°ãƒ‘ã‚¹","ã‚­ãƒ¼ãƒ—åŠ›","ã‚³ãƒ³ã‚¿ã‚¯ãƒˆ","æ•æ·æ€§","å†·é™ã•","ã‚­ãƒƒã‚¯ç²¾åº¦","ãƒœãƒ¼ãƒ«ã‚¿ãƒƒãƒ","ã‚¹ã‚¿ãƒŸãƒŠ","ã‚¿ãƒƒã‚¯ãƒ«","ãƒ‘ã‚¹ã‚«ãƒƒãƒˆ","ãƒãƒ¼ã‚¯","ã‚»ãƒ¼ãƒ“ãƒ³ã‚°","åå¿œé€Ÿåº¦","1å¯¾1"];
    const GK_STATS = ["ã‚»ãƒ¼ãƒ“ãƒ³ã‚°","åå¿œé€Ÿåº¦","1å¯¾1"];
    
    const POS_MAP = {
        "GK": ["ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼GK", "ã‚ªãƒ¼ã‚½ãƒ‰ãƒƒã‚¯ã‚¹GK"],
        "CB": ["çµ„ç«‹CB", "ã‚¹ãƒˆãƒƒãƒ‘ãƒ¼"],
        "LB": ["å®ˆå‚™çš„FB", "æ”»æ’ƒçš„FB"],
        "RB": ["å®ˆå‚™çš„FB", "æ”»æ’ƒçš„FB"],
        "DM": ["ãƒãƒ¼ãƒ‰ãƒãƒ¼ã‚«ãƒ¼", "ã‚»ãƒ³ãƒˆãƒ©ãƒ«MF", "ãƒ‘ã‚µãƒ¼"],
        "AM": ["ã‚»ãƒ³ãƒˆãƒ©ãƒ«MF", "ãƒ‘ã‚µãƒ¼", "ã‚¢ã‚¿ãƒƒã‚«ãƒ¼"],
        "LM": ["ãƒ‰ãƒªãƒ–ãƒ©ãƒ¼", "ã‚µã‚¤ãƒ‰ã‚¢ã‚¿ãƒƒã‚«ãƒ¼"],
        "RM": ["ãƒ‰ãƒªãƒ–ãƒ©ãƒ¼", "ã‚µã‚¤ãƒ‰ã‚¢ã‚¿ãƒƒã‚«ãƒ¼"],
        "LW": ["ãƒ‰ãƒªãƒ–ãƒ©ãƒ¼", "ã‚µã‚¤ãƒ‰ã‚¢ã‚¿ãƒƒã‚«ãƒ¼"],
        "RW": ["ãƒ‰ãƒªãƒ–ãƒ©ãƒ¼", "ã‚µã‚¤ãƒ‰ã‚¢ã‚¿ãƒƒã‚«ãƒ¼"],
        "CF": ["ãƒã‚¹ãƒˆãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼", "ãƒ©ã‚¤ãƒ³ãƒ–ãƒ¬ã‚¤ã‚«ãƒ¼", "ã‚¹ãƒˆãƒ©ã‚¤ã‚«ãƒ¼"]
    };

    let cardsDB = [], skillsDB = [], abilitiesDB = [];
    let myCards = {};
    let selectedSlots = Array(6).fill(null);
    let activeSlotIndex = null;

    // --- åˆæœŸåŒ– ---
    window.onload = async () => {
        document.getElementById('ghToken').value = localStorage.getItem('gh_token') || '';
        document.getElementById('ghRepo').value = localStorage.getItem('gh_repo') || '';
        myCards = JSON.parse(localStorage.getItem('tra_my_cards') || '{}');

        initStatInputs();
        initPosSelect();
        initEditors();
        
        await fetchAllDB();
    };

    function initStatInputs() {
        const area = document.getElementById('statInputArea');
        STATS.forEach(s => {
            const isGk = GK_STATS.includes(s);
            area.innerHTML += `
                <div class="stat-item ${isGk?'gk-stat':''}" style="background:#0f172a; padding:5px; border-radius:4px;">
                    <label>${s}</label>
                    <div style="display:flex; gap:2px;">
                        <input type="number" placeholder="ç¾åœ¨" id="now_${s}" onchange="updateCalc()" style="font-size:0.7rem; padding:4px;">
                        <input type="number" placeholder="æœ€å¤§" id="max_${s}" onchange="updateCalc()" style="font-size:0.7rem; padding:4px;">
                    </div>
                    <div id="gap_${s}" style="text-align:right; font-size:0.7rem; color:#64748b;">æ®‹: -</div>
                </div>`;
        });
    }

    function initPosSelect() {
        const sel = document.getElementById('simPos');
        Object.keys(POS_MAP).forEach(p => sel.innerHTML += `<option value="${p}">${p}</option>`);
        updateStyleOptions();
    }

    function updateStyleOptions() {
        const pos = document.getElementById('simPos').value;
        const styleSel = document.getElementById('simStyle');
        styleSel.innerHTML = "";
        (POS_MAP[pos] || []).forEach(s => styleSel.innerHTML += `<option value="${s}">${s}</option>`);
        updateCalc();
    }

    function initEditors() {
        const grid = document.getElementById('editStatsGrid');
        STATS.forEach(s => grid.innerHTML += `<div class="stat-item ${GK_STATS.includes(s)?'gk-stat':''}"><label>${s}</label><input type="number" step="0.1" class="edit-val" data-stat="${s}"></div>`);
        const saTgt = document.getElementById('saTargets');
        STATS.forEach(s => saTgt.innerHTML += `<label style="font-size:0.7rem;"><input type="checkbox" value="${s}" name="sa_tgt"> ${s}</label>`);
        const areaGrid = document.getElementById('saAreaGrid');
        for(let i=0; i<9; i++) areaGrid.innerHTML += `<div class="area-cell" onclick="this.classList.toggle('active')"></div>`;
    }

    async function fetchAllDB() {
        const ts = Date.now(), base = './data';
        try {
            const [c, s, a] = await Promise.all([ fetch(`${base}/cards.json?t=${ts}`), fetch(`${base}/skills.json?t=${ts}`), fetch(`${base}/abilities.json?t=${ts}`) ]);
            if(c.ok) cardsDB = await c.json(); if(s.ok) skillsDB = await s.json(); if(a.ok) abilitiesDB = await a.json();
            
            renderCardList(); 
            renderInventory(); 
            renderSAList(); 
            updateAutoComplete(); 
            updateCalc();
        } catch(e) { console.error(e); }
    }

    // --- è¨ˆç®—ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ ---
    function getCardStatsAtLevel(card, level, targetPos, targetStyle, conditionMult) {
        const maxLevel = card.rarity === 'SSR' ? 50 : 45;
        const useLevel = Math.max(1, Math.min(maxLevel, level));
        
        let bonusTotal = 0;
        if (card.bonus_type) {
            if (card.bonus_type === targetPos || card.bonus_type === targetStyle) {
                bonusTotal += (card.bonus_value || 0);
            }
        }
        if (card.bonuses && Array.isArray(card.bonuses)) {
            card.bonuses.forEach(b => {
                if (b.type === targetPos || b.type === targetStyle) {
                    bonusTotal += b.value;
                }
            });
        }
        
        const bonusMult = 1 + (bonusTotal / 100);
        const result = {};

        for (let s in card.stats) {
            const d1 = card.stats[s];
            if (!d1) continue;

            const d1_int = Math.round(d1 * 10);
            const N = Math.round(d1 * 6);
            
            const growthMax = (N * 10 - d1_int);
            const growthCurrent = Math.floor(growthMax * (useLevel - 1) / (maxLevel - 1));
            const vBase_x10 = d1_int + growthCurrent;
            const val_x10 = Math.round(vBase_x10 * conditionMult * bonusMult);
            
            result[s] = val_x10;
        }
        return result;
    }

    function updateCalc() {
        const condMult = parseFloat(document.getElementById('conditionMod').value);
        const pos = document.getElementById('simPos').value;
        const style = document.getElementById('simStyle').value;
        const targetSkill = document.getElementById('targetSkillInput').value;

        const totals_x10 = {};
        const saList = new Set();
        let hasTargetSkill = false;

        selectedSlots.forEach((card, idx) => {
            if (!card) return;
            const key = card.name + "_" + card.title;
            const invData = myCards[key];
            const level = (invData && invData.level) ? parseInt(invData.level) : (card.rarity==='SSR'?50:45);

            const vals = getCardStatsAtLevel(card, level, pos, style, condMult);
            
            for(let s in vals) {
                totals_x10[s] = (totals_x10[s] || 0) + vals[s];
            }

            if(card.abilities && card.abilities.length > 0) {
                card.abilities.forEach(a => {
                    saList.add(a);
                    if(a === targetSkill) hasTargetSkill = true;
                });
            }
        });

        renderResults(totals_x10, saList, targetSkill, hasTargetSkill);
        renderSimSlots(pos, style);
    }

    function renderResults(totals_x10, saList, targetSkill, hasTargetSkill) {
        const resDiv = document.getElementById('totalResults');
        resDiv.innerHTML = '<h4>ç‰¹ç·´ ä¸Šæ˜‡å€¤ vs Gap</h4>';
        
        STATS.forEach(s => {
            const now = parseFloat(document.getElementById(`now_${s}`).value) || 0;
            const max = parseFloat(document.getElementById(`max_${s}`).value) || 0;
            const gap = (max > 0 && now > 0) ? (max - now) : null;
            
            const gapEl = document.getElementById(`gap_${s}`);
            if(gap !== null) { gapEl.innerHTML = `æ®‹: <b>${gap.toFixed(1)}</b>`; gapEl.style.color = "#fbbf24"; }
            else { gapEl.innerHTML = `æ®‹: -`; gapEl.style.color = "#64748b"; }

            if(totals_x10[s] > 0) {
                const finalVal = totals_x10[s] / 10;
                let color = "#fff", note = "";
                if(gap !== null) {
                    if(finalVal > gap) { color = "#ef4444"; note = ` (${(finalVal-gap).toFixed(1)}éå‰°)`; }
                    else if(finalVal >= gap * 0.9) color = "#22c55e";
                }
                resDiv.innerHTML += `<div style="display:flex; justify-content:space-between; font-size:0.85rem; border-bottom:1px solid #333; padding:2px 0;"><span>${s}</span><b style="color:${color}">+${finalVal.toFixed(1)}${note}</b></div>`; 
            }
        });

        const saDiv = document.getElementById('saResults');
        let header = '<h4>äºˆå®šã‚¹ã‚­ãƒ«/ã‚¢ãƒ“</h4>';
        if(targetSkill && !hasTargetSkill) header += `<div style="color:red; font-size:0.7rem;">âš  å¿…é ˆã‚¹ã‚­ãƒ«ã€Œ${targetSkill}ã€ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“</div>`;
        else if(targetSkill) header += `<div style="color:var(--accent); font-size:0.7rem;">âœ” å¿…é ˆã‚¹ã‚­ãƒ«ã€Œ${targetSkill}ã€OK</div>`;
        saDiv.innerHTML = header;

        saList.forEach(name => {
            const s = skillsDB.find(i=>i.name===name), a = abilitiesDB.find(i=>i.name===name);
            const isTarget = (name === targetSkill);
            const hlStyle = isTarget ? 'border:1px solid var(--accent); padding:2px;' : '';
            
            if(s) {
                let areaH = '<div class="sa-result-area">';
                (s.area || Array(9).fill(0)).forEach(v => areaH += `<div class="sa-result-cell ${v?'active':''}"></div>`);
                saDiv.innerHTML += `<div style="display:flex; align-items:center; margin-bottom:5px; width:100%; ${hlStyle}">${areaH}<div style="flex:1; min-width:0; white-space:nowrap;"><span class="tag tag-skill">S</span><b>${name}</b><br><small>${s.value}%</small></div></div>`;
            }
            if(a) saDiv.innerHTML += `<div style="margin-bottom:5px; width:100%; white-space:nowrap; ${hlStyle}"><span class="tag tag-ability">A</span><b>${name}</b><br><small>${a.condition || ''}</small></div>`;
        });
    }

    function renderSimSlots(pos, style) {
        const g = document.getElementById('simSlots');
        g.innerHTML = '';
        selectedSlots.forEach((c, i) => {
            let h = `æ  ${i+1}`;
            if (c) {
                let bVal = 0;
                if(c.bonus_type === pos || c.bonus_type === style) bVal += (c.bonus_value||0);
                if(c.bonuses) c.bonuses.forEach(b => { if(b.type===pos || b.type===style) bVal += b.value; });
                
                const bDisplay = bVal > 0 ? `<div class="bonus-on" style="font-size:0.6rem;">Bonus +${bVal}%</div>` : `<div class="bonus-off" style="font-size:0.6rem;">No Bonus</div>`;
                h = `<div style="font-weight:bold;font-size:0.7rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;">${c.name}</div>${bDisplay}`;
            }
            g.innerHTML += `<div onclick="openModal(${i})" class="${c?'slot-active':'slot-empty'}" style="height:65px;border-radius:8px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;text-align:center;padding:2px;">${h}</div>`;
        });
    }

    // --- ã‚ªãƒ¼ãƒˆç·¨æˆ ---
    window.runAutoSim = () => {
        if(cardsDB.length === 0) return alert("ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
        
        const ownedCards = cardsDB.map((c, idx) => {
            const k = c.name + "_" + c.title;
            const inv = myCards[k];
            if (!inv || !inv.owned) return null;
            
            return {
                id: idx,
                original: c,
                vals: getCardStatsAtLevel(c, parseInt(inv.level), document.getElementById('simPos').value, document.getElementById('simStyle').value, parseFloat(document.getElementById('conditionMod').value))
            };
        }).filter(x => x !== null);

        if(ownedCards.length === 0) return alert("æ‰€æŒã‚«ãƒ¼ãƒ‰ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã€Œæ‰€æŒã‚«ãƒ¼ãƒ‰ã€ã‚¿ãƒ–ã§è¨­å®šã—ã¦ãã ã•ã„ã€‚");

        const targetSkill = document.getElementById('targetSkillInput').value;
        const targetPct = parseInt(document.getElementById('targetPct').value) / 100;
        
        const gaps = {};
        STATS.forEach(s => {
            const now = parseFloat(document.getElementById(`now_${s}`).value) || 0;
            const max = parseFloat(document.getElementById(`max_${s}`).value) || 0;
            gaps[s] = (max > 0) ? Math.max(0, max - now) * targetPct : 999999;
        });

        const getScore = (sums) => {
            let sc = 0; STATS.forEach(s => sc += Math.min((sums[s]||0)/10, gaps[s])); return sc;
        };

        let candidateRoots = [];
        if (targetSkill) {
            const skillHolders = ownedCards.filter(c => c.original.abilities && c.original.abilities.includes(targetSkill));
            if (skillHolders.length === 0) return alert(`ã‚¹ã‚­ãƒ«ã€Œ${targetSkill}ã€ã‚’æŒã¤æ‰€æŒã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`);
            
            skillHolders.forEach(holder => {
                candidateRoots.push({
                    fixed: [holder],
                    pool: ownedCards
                });
            });
        } else {
            candidateRoots.push({ fixed: [], pool: ownedCards });
        }

        let bestResult = null;
        let maxScore = -1;

        candidateRoots.forEach(root => {
            let beam = [{ idxs: root.fixed.map(x=>x.id), sums: {}, score: 0 }];
            if(root.fixed.length > 0) {
                 root.fixed.forEach(f => {
                     for(let s in f.vals) beam[0].sums[s] = (beam[0].sums[s]||0) + f.vals[s];
                 });
                 beam[0].score = getScore(beam[0].sums);
            }

            const slotsToFill = 6 - root.fixed.length;
            const WIDTH = 500;

            for(let step=0; step < slotsToFill; step++) {
                let next = [];
                for(const node of beam) {
                    for(const card of root.pool) {
                        const nSums = { ...node.sums };
                        for(const s in card.vals) nSums[s] = (nSums[s]||0) + card.vals[s];
                        next.push({ idxs: [...node.idxs, card.id], sums: nSums, score: getScore(nSums) });
                    }
                }
                next.sort((a,b) => b.score - a.score);
                beam = next.slice(0, WIDTH);
            }

            if(beam.length > 0 && beam[0].score > maxScore) {
                maxScore = beam[0].score;
                bestResult = beam[0];
            }
        });

        if(bestResult) {
            selectedSlots = bestResult.idxs.map(i => cardsDB[i]);
            updateCalc();
            alert(`æœ€é©åŒ–å®Œäº† (ã‚¹ã‚³ã‚¢: ${maxScore.toFixed(1)})`);
        }
    };

    // --- ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªç®¡ç† ---
    function renderInventory() {
        const div = document.getElementById('invList');
        div.innerHTML = '';
        cardsDB.forEach((c, idx) => {
            const key = c.name + "_" + c.title;
            const data = myCards[key] || { owned: false, level: c.rarity==='SSR'?50:45 };
            const maxL = c.rarity==='SSR'?50:45;

            div.innerHTML += `
            <div class="inv-item ${data.owned?'owned':'unowned'}">
                <input type="checkbox" class="inv-check" onchange="toggleOwn('${key}', this.checked)" ${data.owned?'checked':''}>
                <div style="font-size:0.8rem; font-weight:bold; margin-right:20px;">${c.name}</div>
                <div style="font-size:0.65rem; color:#aaa; margin-bottom:5px;">${c.title}</div>
                <div style="display:flex; align-items:center; gap:5px;">
                    <span style="font-size:0.7rem;">Lv</span>
                    <input type="number" min="1" max="${maxL}" value="${data.level}" 
                        style="width:45px; padding:2px; font-size:0.75rem;" 
                        onchange="updateOwnLvl('${key}', this.value)" ${!data.owned?'disabled':''}>
                </div>
            </div>`;
        });
    }

    window.toggleOwn = (key, checked) => {
        if(!myCards[key]) myCards[key] = { level: 50 };
        myCards[key].owned = checked;
        saveInv(); renderInventory();
    };
    window.updateOwnLvl = (key, lvl) => {
        if(!myCards[key]) myCards[key] = { owned: true };
        myCards[key].level = lvl;
        saveInv();
    };
    window.invSetAll = (owned) => {
        cardsDB.forEach(c => {
            const key = c.name+"_"+c.title;
            const maxL = c.rarity==='SSR'?50:45;
            myCards[key] = { owned: owned, level: maxL };
        });
        saveInv(); renderInventory();
    };
    function saveInv() { localStorage.setItem('tra_my_cards', JSON.stringify(myCards)); }

    // --- ã‚«ãƒ¼ãƒ‰ç®¡ç† ---
    function loadCardToEditor(d) {
        if(!d) {
            document.querySelectorAll('.edit-val').forEach(i=>i.value='');
            document.getElementById('editBonusList').innerHTML = '';
            return;
        }
        document.getElementById('editName').value = d.name;
        document.getElementById('editTitle').value = d.title;
        document.getElementById('editRarity').value = d.rarity;
        document.getElementById('editAbilityName').value = d.abilities[0]||'';
        document.querySelectorAll('.edit-val').forEach(i=>i.value=d.stats[i.dataset.stat]||'');
        
        const bList = document.getElementById('editBonusList');
        bList.innerHTML = '';
        if (d.bonuses) {
            d.bonuses.forEach(b => addBonusRow(b.type, b.value));
        } else if (d.bonus_type) {
            addBonusRow(d.bonus_type, d.bonus_value);
        }
    }

    window.addBonusRow = (type='', val='') => {
        const div = document.createElement('div');
        div.style.cssText = "display:flex; gap:5px; margin-bottom:3px;";
        div.innerHTML = `<input class="edit-b-type" placeholder="æ¡ä»¶(CF,ã‚¹ãƒˆãƒ©ã‚¤ã‚«ãƒ¼ç­‰)" value="${type}" list="styleSuggestions">
                         <input class="edit-b-val" type="number" placeholder="%" value="${val}" style="width:60px;">
                         <button class="btn btn-sm" style="background:#ef4444;" onclick="this.parentElement.remove()">Ã—</button>`;
        document.getElementById('editBonusList').appendChild(div);
    }

    async function saveCardToGH() {
        const name=document.getElementById('editName').value, title=document.getElementById('editTitle').value; if(!name) return;
        const stats={}; document.querySelectorAll('.edit-val').forEach(i=>{if(i.value) stats[i.dataset.stat]=parseFloat(i.value)});
        
        const bonuses = [];
        const rows = document.querySelectorAll('#editBonusList > div');
        rows.forEach(r => {
            const t = r.querySelector('.edit-b-type').value;
            const v = parseFloat(r.querySelector('.edit-b-val').value);
            if(t && v) bonuses.push({ type: t, value: v });
        });

        const legacyType = bonuses.length > 0 ? bonuses[0].type : "";
        const legacyVal = bonuses.length > 0 ? bonuses[0].value : 0;

        const nc = { 
            title, name, 
            rarity:document.getElementById('editRarity').value, 
            bonuses: bonuses,
            bonus_type: legacyType,
            bonus_value: legacyVal,
            abilities:[document.getElementById('editAbilityName').value], 
            stats 
        };

        const i=cardsDB.findIndex(x=>x.name===name&&x.title===title); 
        if(i>=0) cardsDB[i]=nc; else cardsDB.push(nc);
        
        if(await pushToGH('cards.json',cardsDB,"Update Card")) { alert("ä¿å­˜æˆåŠŸ"); renderCardList(); renderInventory(); }
    }

    // --- ãã®ä»–å…±é€šé–¢æ•° ---
    async function pushToGH(file, data, msg) {
        const token = document.getElementById('ghToken').value, repo = document.getElementById('ghRepo').value;
        if(!token || !repo) { alert("GitHubè¨­å®šãŒå¿…è¦ã§ã™"); return false; }
        const url = `https://api.github.com/repos/${repo}/contents/data/${file}`;
        try {
            const g = await fetch(url, { headers:{'Authorization':`token ${token}`} });
            const sha = g.ok ? (await g.json()).sha : null;
            const res = await fetch(url, { method:'PUT', headers:{'Authorization':`token ${token}`}, body: JSON.stringify({ message:msg, sha:sha, content: btoa(unescape(encodeURIComponent(JSON.stringify(data, null, 2)))) }) });
            return res.ok;
        } catch(e) { console.error(e); return false; }
    }
    
    // --- OCRé–¢é€£ (å®Œå…¨ç‰ˆ) ---
    const OCR_GRID_DEFS = [
        { name: "æ±ºå®šåŠ›", r: 0, c: 0 }, { name: "ã‚·ãƒ§ãƒ¼ãƒˆãƒ‘ã‚¹", r: 0, c: 1 }, { name: "çªç ´åŠ›", r: 0, c: 2 }, { name: "ã‚¿ãƒƒã‚¯ãƒ«", r: 0, c: 3 }, { name: "ã‚¸ãƒ£ãƒ³ãƒ—", r: 0, c: 4 }, { name: "èµ°åŠ›", r: 0, c: 5 },
        { name: "ã‚­ãƒƒã‚¯åŠ›", r: 1, c: 0 }, { name: "ãƒ­ãƒ³ã‚°ãƒ‘ã‚¹", r: 1, c: 1 }, { name: "ã‚­ãƒ¼ãƒ—åŠ›", r: 1, c: 2 }, { name: "ãƒ‘ã‚¹ã‚«ãƒƒãƒˆ", r: 1, c: 3 }, { name: "ã‚³ãƒ³ã‚¿ã‚¯ãƒˆ", r: 1, c: 4 }, { name: "æ•æ·æ€§", r: 1, c: 5 },
        { name: "å†·é™ã•", r: 2, c: 0 }, { name: "ã‚­ãƒƒã‚¯ç²¾åº¦", r: 2, c: 1 }, { name: "ãƒœãƒ¼ãƒ«ã‚¿ãƒƒãƒ", r: 2, c: 2 }, { name: "ãƒãƒ¼ã‚¯", r: 2, c: 3 }, { name: "ã‚¹ã‚¿ãƒŸãƒŠ", r: 2, c: 4 }
    ];

    async function handleOCR(input) {
        const file = input.files[0];
        if (!file) return;
        const statusEl = document.getElementById('ocrStatus');
        statusEl.innerText = "èª­ã¿å–ã‚Šä¸­...";

        const img = new Image();
        img.onload = async () => {
            const scale = 3.5;
            const cvs = document.createElement('canvas');
            const ctx = cvs.getContext('2d');
            cvs.width = img.width * scale; cvs.height = img.height * scale;
            ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
            
            const imageData = ctx.getImageData(0, 0, cvs.width, cvs.height);
            const d = imageData.data;
            const grayData = new Uint8Array(cvs.width * cvs.height);
            for (let i = 0; i < d.length; i += 4) {
                const b = (d[i] + d[i+1] + d[i+2]) / 3;
                grayData[i/4] = b;
            }

            // 1. ã‚°ãƒªãƒƒãƒ‰(æ°´å¹³ç·š)æ¤œå‡º
            const scanL = Math.floor(cvs.width * 0.42), scanR = Math.floor(cvs.width * 0.98), scanW = scanR - scanL;
            const lineHits = [];
            for(let y=0; y < cvs.height; y++) {
                let count = 0;
                for(let x=scanL; x < scanR; x++) if(grayData[y * cvs.width + x] > 115) count++;
                if(count > scanW * 0.55) lineHits.push(y);
            }
            const rowYs = [];
            if(lineHits.length > 0) {
                let group = [lineHits[0]];
                for(let i=1; i < lineHits.length; i++){
                    if(lineHits[i] - lineHits[i-1] < 20) group.push(lineHits[i]);
                    else { rowYs.push(group[Math.floor(group.length/2)]); group = [lineHits[i]]; }
                }
                rowYs.push(group[Math.floor(group.length/2)]);
            }
            if(rowYs.length < 3) { statusEl.innerText = "ã‚°ãƒªãƒƒãƒ‰æ¤œå‡ºå¤±æ•—"; return; }
            const targetRows = rowYs.slice(-3);

            // 2. åˆ—ä½ç½®ã®ç¢ºå®š
            let islands = [];
            const refY = targetRows[0] - Math.floor(80 * scale / 3), refH = Math.floor(60 * scale / 3);
            const hProj = new Array(scanW).fill(0);
            for(let x=0; x < scanW; x++) for(let y=refY; y < refY+refH; y++) if(grayData[y * cvs.width + (scanL+x)] > 120) hProj[x]++;
            
            let inIsland = false, sX = 0;
            for(let x=0; x < scanW; x++){
                if(!inIsland && hProj[x] > 2) { inIsland = true; sX = x; }
                else if(inIsland && hProj[x] <= 2) {
                    let gap = 0; while(x+gap < scanW && hProj[x+gap] <= 2) gap++;
                    if(gap < 20) x += gap;
                    else { inIsland = false; if(x - sX > 100) islands.push({x: scanL + sX, w: x - sX}); }
                }
            }
            let xCoords = [];
            if (islands.length >= 2) {
                const pitch = (islands[islands.length-1].x - islands[0].x) / (islands.length-1);
                const startX = islands[0].x - (Math.round((islands[0].x - scanL) / pitch) * pitch);
                for(let c=0; c<6; c++) xCoords.push({ x: startX + (c * pitch), w: islands[0].w });
            } else { statusEl.innerText = "åˆ—ä½ç½®ç‰¹å®šå¤±æ•—"; return; }

            // 3. OCRãƒ—ãƒ­ã‚»ã‚¹
            const worker = await Tesseract.createWorker('eng');
            await worker.setParameters({ tessedit_char_whitelist: '0123456789/', tessedit_pageseg_mode: '7' });

            for (let i = 0; i < OCR_GRID_DEFS.length; i++) {
                const def = OCR_GRID_DEFS[i];
                const xObj = xCoords[def.c];
                const cropW = Math.floor(xObj.w + 65), cropX = Math.floor(xObj.x - 48);
                const cropH = Math.floor(100 * scale / 3), cropY = targetRows[def.r] - cropH + 5;
                
                const process = async (thresh) => {
                    const tCvs = document.createElement('canvas');
                    tCvs.width = cropW + 100; tCvs.height = cropH + 100;
                    const tCtx = tCvs.getContext('2d');
                    tCtx.fillStyle = "white"; tCtx.fillRect(0,0,tCvs.width,tCvs.height);
                    const sCvs = document.createElement('canvas');
                    sCvs.width = cropW; sCvs.height = cropH;
                    const sCtx = sCvs.getContext('2d');
                    sCtx.drawImage(img, cropX/scale, cropY/scale, cropW/scale, cropH/scale, 0, 0, cropW, cropH);
                    const sd = sCtx.getImageData(0,0,cropW,cropH);
                    for(let j=0; j<sd.data.length; j+=4){
                        const v = ((sd.data[j]+sd.data[j+1]+sd.data[j+2])/3 > thresh) ? 0 : 255;
                        sd.data[j]=sd.data[j+1]=sd.data[j+2]=v;
                    }
                    const cutY = Math.floor(cropH * 0.85);
                    for(let y=cutY; y<cropH; y++) for(let x=0; x<cropW; x++) {
                        const idx = (y*cropW+x)*4; sd.data[idx]=sd.data[idx+1]=sd.data[idx+2]=255;
                    }
                    sCtx.putImageData(sd, 0, 0);
                    tCtx.drawImage(sCvs, 50, 50);
                    const { data: { text } } = await worker.recognize(tCvs);
                    return text.trim().replace(/[^0-9/]/g, '');
                };

                const r1 = await process(110);
                const r2 = await process(135);
                let clean = (r2.includes('/') && r2.length >= 5) ? r2 : r1;

                let n = "", m = "";
                if (clean.includes('/')) {
                    const p = clean.split('/'); n = p[0].substring(0,3); m = p[1].substring(0,3);
                } else if (clean.length >= 5) {
                    n = clean.substring(0,3); m = clean.substring(3,6);
                } else if (clean.length >= 3) {
                    n = clean.substring(0,3);
                }

                if (n) document.getElementById(`now_${def.name}`).value = n;
                if (m) document.getElementById(`max_${def.name}`).value = m;
                statusEl.innerText = `è§£æä¸­... (${i+1}/17)`;
            }

            statusEl.innerText = "è§£æå®Œäº†";
            await worker.terminate();
            updateCalc();
        };
        img.src = URL.createObjectURL(file);
    }
    
    function showTab(id) { document.querySelectorAll('.content').forEach(c=>c.classList.remove('active')); document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active')); document.getElementById(id).classList.add('active'); event.target.classList.add('active'); }
    function toggleDisp(id) { const e=document.getElementById(id); e.style.display = e.style.display==='none'?'grid':'none'; }
    function openModal(i) { activeSlotIndex=i; const m=document.getElementById('modalList'); m.innerHTML='<div class="card-box" onclick="selectSlot(null)">ï¼ˆç©ºï¼‰</div>'; cardsDB.forEach((c,idx)=>{ if(myCards[c.name+"_"+c.title]?.owned){ m.innerHTML+=`<div class="card-box" onclick="selectSlot(${idx})">${c.title}<br><b>${c.name}</b></div>`; }}); document.getElementById('cardModal').style.display='block'; }
    function selectSlot(i) { selectedSlots[activeSlotIndex] = i===null?null:cardsDB[i]; document.getElementById('cardModal').style.display='none'; updateCalc(); }
    
    function renderCardList() { const l=document.getElementById('masterList'); l.innerHTML=''; cardsDB.forEach((c,idx)=>l.innerHTML+=`<div class="list-item"><b>${c.name}</b><div style="display:flex;gap:5px;"><button class="btn-edit" onclick="loadCardToEditor(cardsDB[${idx}])">ç·¨é›†</button><button class="btn-edit" style="background:#ef4444;" onclick="deleteCard(${idx})">å‰Šé™¤</button></div></div>`); }
    async function deleteCard(idx) { if(!confirm("å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return; cardsDB.splice(idx,1); await pushToGH('cards.json',cardsDB,"Delete Card"); renderCardList(); renderInventory(); }
    async function batchRegisterCards() { try { const d=JSON.parse(document.getElementById('aiPasteCard').value); (Array.isArray(d)?d:[d]).forEach(c=>{const i=cardsDB.findIndex(x=>x.name===c.name&&x.title===c.title); if(i>=0)cardsDB[i]=c; else cardsDB.push(c);}); await pushToGH('cards.json',cardsDB,"Bulk Update"); alert("ä¿å­˜æˆåŠŸ"); renderCardList(); renderInventory(); } catch(e){alert("JSONã‚¨ãƒ©ãƒ¼");} }

    // SAé–¢é€£
    function renderSAList() { const l=document.getElementById('saList'); l.innerHTML=''; skillsDB.forEach(s=>l.innerHTML+=`<div class="list-item"><span><span class="tag tag-skill">S</span>${s.name}</span><div style="display:flex;gap:5px;"><button class="btn-edit" onclick="loadSA('skill','${s.name}')">ç·¨é›†</button><button class="btn-edit" style="background:#ef4444;" onclick="deleteSA('skill','${s.name}')">å‰Šé™¤</button></div></div>`); abilitiesDB.forEach(a=>l.innerHTML+=`<div class="list-item"><span><span class="tag tag-ability">A</span>${a.name}</span><div style="display:flex;gap:5px;"><button class="btn-edit" onclick="loadSA('ability','${a.name}')">ç·¨é›†</button><button class="btn-edit" style="background:#ef4444;" onclick="deleteSA('ability','${a.name}')">å‰Šé™¤</button></div></div>`); }
    function updateAutoComplete() { 
        const l=document.getElementById('skillList'); l.innerHTML=''; 
        [...skillsDB,...abilitiesDB].forEach(i=>l.innerHTML+=`<option value="${i.name}">`); 
        const sSug = document.getElementById('styleSuggestions'); 
        if(sSug) { sSug.innerHTML=''; Object.values(POS_MAP).flat().forEach(s=>sSug.innerHTML+=`<option value="${s}">`); Object.keys(POS_MAP).forEach(p=>sSug.innerHTML+=`<option value="${p}">`); }
    }
    window.loadSA = (type, name) => { const db = type==='skill'?skillsDB:abilitiesDB, item = db.find(i=>i.name===name); if(!item) return; document.getElementById('saType').value = type; toggleAreaGrid(); document.getElementById('saName').value = item.name; document.getElementById('saValue').value = item.value||''; document.getElementById('saCondition').value = item.condition||''; document.querySelectorAll('input[name="sa_tgt"]').forEach(c => c.checked = item.targets?.includes(c.value)); const cells = document.querySelectorAll('.area-cell'); cells.forEach((c,idx) => { c.classList.remove('active'); if(type==='skill'&&item.area?.[idx]) c.classList.add('active'); }); };
    window.saveSA = async () => { const type=document.getElementById('saType').value, name=document.getElementById('saName').value; if(!name) return; const tgts = Array.from(document.querySelectorAll('input[name="sa_tgt"]:checked')).map(c=>c.value); const data = { name, value:parseFloat(document.getElementById('saValue').value)||0, targets:tgts }; if(type==='skill'){ data.area = Array.from(document.querySelectorAll('.area-cell')).map(c=>c.classList.contains('active')?1:0); const i=skillsDB.findIndex(s=>s.name===name); if(i>=0)skillsDB[i]=data; else skillsDB.push(data); await pushToGH('skills.json',skillsDB,"Update Skill"); } else { data.condition = document.getElementById('saCondition').value; const i=abilitiesDB.findIndex(a=>a.name===name); if(i>=0) abilitiesDB[i]=data; else abilitiesDB.push(data); await pushToGH('abilities.json',abilitiesDB,"Update Ability"); } alert("ä¿å­˜å®Œäº†"); renderSAList(); updateAutoComplete(); };
    window.deleteSA = async (type, name) => { if(!confirm("å‰Šé™¤ï¼Ÿ")) return; if(type==='skill') skillsDB=skillsDB.filter(s=>s.name!==name); else abilitiesDB=abilitiesDB.filter(a=>a.name!==name); await pushToGH(type==='skill'?'skills.json':'abilities.json', type==='skill'?skillsDB:abilitiesDB, "Delete SA"); renderSAList(); };
    async function batchRegisterSA() { try { const d=JSON.parse(document.getElementById('aiPasteSA').value); if(d.skills) d.skills.forEach(s=>{const i=skillsDB.findIndex(x=>x.name===s.name); if(i>=0)skillsDB[i]=s; else skillsDB.push(s);}); if(d.abilities) d.abilities.forEach(a=>{const i=abilitiesDB.findIndex(x=>x.name===a.name); if(i>=0)abilitiesDB[i]=a; else abilitiesDB.push(a);}); await pushToGH('skills.json',skillsDB,"Update"); await pushToGH('abilities.json',abilitiesDB,"Update"); alert("ä¿å­˜æˆåŠŸ"); renderSAList(); } catch(e){alert("JSONã‚¨ãƒ©ãƒ¼");} }
    function toggleAreaGrid() { document.getElementById('areaContainer').style.display = document.getElementById('saType').value==='skill'?'block':'none'; }
</script>
</body>
</html>